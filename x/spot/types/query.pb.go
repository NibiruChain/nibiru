// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: spot/v1/query.proto

package types

import (
	context "context"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	query "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParamsRequest is request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         { *m = QueryParamsRequest{} }
func (m *QueryParamsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryParamsRequest) ProtoMessage()    {}
func (*QueryParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{0}
}
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}
func (m *QueryParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is response type for the Query/Params RPC method.
type QueryParamsResponse struct {
	// params holds all the parameters of this module.
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         { *m = QueryParamsResponse{} }
func (m *QueryParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryParamsResponse) ProtoMessage()    {}
func (*QueryParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{1}
}
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}
func (m *QueryParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

type QueryPoolNumberRequest struct {
}

func (m *QueryPoolNumberRequest) Reset()         { *m = QueryPoolNumberRequest{} }
func (m *QueryPoolNumberRequest) String() string { return proto.CompactTextString(m) }
func (*QueryPoolNumberRequest) ProtoMessage()    {}
func (*QueryPoolNumberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{2}
}
func (m *QueryPoolNumberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoolNumberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoolNumberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoolNumberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoolNumberRequest.Merge(m, src)
}
func (m *QueryPoolNumberRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoolNumberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoolNumberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoolNumberRequest proto.InternalMessageInfo

type QueryPoolNumberResponse struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
}

func (m *QueryPoolNumberResponse) Reset()         { *m = QueryPoolNumberResponse{} }
func (m *QueryPoolNumberResponse) String() string { return proto.CompactTextString(m) }
func (*QueryPoolNumberResponse) ProtoMessage()    {}
func (*QueryPoolNumberResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{3}
}
func (m *QueryPoolNumberResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoolNumberResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoolNumberResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoolNumberResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoolNumberResponse.Merge(m, src)
}
func (m *QueryPoolNumberResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoolNumberResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoolNumberResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoolNumberResponse proto.InternalMessageInfo

func (m *QueryPoolNumberResponse) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type QueryPoolRequest struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
}

func (m *QueryPoolRequest) Reset()         { *m = QueryPoolRequest{} }
func (m *QueryPoolRequest) String() string { return proto.CompactTextString(m) }
func (*QueryPoolRequest) ProtoMessage()    {}
func (*QueryPoolRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{4}
}
func (m *QueryPoolRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoolRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoolRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoolRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoolRequest.Merge(m, src)
}
func (m *QueryPoolRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoolRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoolRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoolRequest proto.InternalMessageInfo

func (m *QueryPoolRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type QueryPoolResponse struct {
	Pool *Pool `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool,omitempty"`
}

func (m *QueryPoolResponse) Reset()         { *m = QueryPoolResponse{} }
func (m *QueryPoolResponse) String() string { return proto.CompactTextString(m) }
func (*QueryPoolResponse) ProtoMessage()    {}
func (*QueryPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{5}
}
func (m *QueryPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoolResponse.Merge(m, src)
}
func (m *QueryPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoolResponse proto.InternalMessageInfo

func (m *QueryPoolResponse) GetPool() *Pool {
	if m != nil {
		return m.Pool
	}
	return nil
}

type QueryPoolsRequest struct {
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryPoolsRequest) Reset()         { *m = QueryPoolsRequest{} }
func (m *QueryPoolsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryPoolsRequest) ProtoMessage()    {}
func (*QueryPoolsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{6}
}
func (m *QueryPoolsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoolsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoolsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoolsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoolsRequest.Merge(m, src)
}
func (m *QueryPoolsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoolsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoolsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoolsRequest proto.InternalMessageInfo

func (m *QueryPoolsRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

type QueryPoolsResponse struct {
	Pools []*Pool `protobuf:"bytes,1,rep,name=pools,proto3" json:"pools,omitempty"`
	// pagination defines the pagination in the response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryPoolsResponse) Reset()         { *m = QueryPoolsResponse{} }
func (m *QueryPoolsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryPoolsResponse) ProtoMessage()    {}
func (*QueryPoolsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{7}
}
func (m *QueryPoolsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoolsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoolsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoolsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoolsResponse.Merge(m, src)
}
func (m *QueryPoolsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoolsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoolsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoolsResponse proto.InternalMessageInfo

func (m *QueryPoolsResponse) GetPools() []*Pool {
	if m != nil {
		return m.Pools
	}
	return nil
}

func (m *QueryPoolsResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

type QueryPoolParamsRequest struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
}

func (m *QueryPoolParamsRequest) Reset()         { *m = QueryPoolParamsRequest{} }
func (m *QueryPoolParamsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryPoolParamsRequest) ProtoMessage()    {}
func (*QueryPoolParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{8}
}
func (m *QueryPoolParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoolParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoolParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoolParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoolParamsRequest.Merge(m, src)
}
func (m *QueryPoolParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoolParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoolParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoolParamsRequest proto.InternalMessageInfo

func (m *QueryPoolParamsRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type QueryPoolParamsResponse struct {
	PoolParams *PoolParams `protobuf:"bytes,1,opt,name=pool_params,json=poolParams,proto3" json:"pool_params,omitempty"`
}

func (m *QueryPoolParamsResponse) Reset()         { *m = QueryPoolParamsResponse{} }
func (m *QueryPoolParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryPoolParamsResponse) ProtoMessage()    {}
func (*QueryPoolParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{9}
}
func (m *QueryPoolParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoolParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoolParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoolParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoolParamsResponse.Merge(m, src)
}
func (m *QueryPoolParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoolParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoolParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoolParamsResponse proto.InternalMessageInfo

func (m *QueryPoolParamsResponse) GetPoolParams() *PoolParams {
	if m != nil {
		return m.PoolParams
	}
	return nil
}

type QueryNumPoolsRequest struct {
}

func (m *QueryNumPoolsRequest) Reset()         { *m = QueryNumPoolsRequest{} }
func (m *QueryNumPoolsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryNumPoolsRequest) ProtoMessage()    {}
func (*QueryNumPoolsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{10}
}
func (m *QueryNumPoolsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryNumPoolsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryNumPoolsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryNumPoolsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryNumPoolsRequest.Merge(m, src)
}
func (m *QueryNumPoolsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryNumPoolsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryNumPoolsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryNumPoolsRequest proto.InternalMessageInfo

type QueryNumPoolsResponse struct {
	NumPools uint64 `protobuf:"varint,1,opt,name=num_pools,json=numPools,proto3" json:"num_pools,omitempty"`
}

func (m *QueryNumPoolsResponse) Reset()         { *m = QueryNumPoolsResponse{} }
func (m *QueryNumPoolsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryNumPoolsResponse) ProtoMessage()    {}
func (*QueryNumPoolsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{11}
}
func (m *QueryNumPoolsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryNumPoolsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryNumPoolsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryNumPoolsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryNumPoolsResponse.Merge(m, src)
}
func (m *QueryNumPoolsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryNumPoolsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryNumPoolsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryNumPoolsResponse proto.InternalMessageInfo

func (m *QueryNumPoolsResponse) GetNumPools() uint64 {
	if m != nil {
		return m.NumPools
	}
	return 0
}

// --------------------------------------------
// Query total liquidity the protocol
type QueryTotalLiquidityRequest struct {
}

func (m *QueryTotalLiquidityRequest) Reset()         { *m = QueryTotalLiquidityRequest{} }
func (m *QueryTotalLiquidityRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTotalLiquidityRequest) ProtoMessage()    {}
func (*QueryTotalLiquidityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{12}
}
func (m *QueryTotalLiquidityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTotalLiquidityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTotalLiquidityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTotalLiquidityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTotalLiquidityRequest.Merge(m, src)
}
func (m *QueryTotalLiquidityRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTotalLiquidityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTotalLiquidityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTotalLiquidityRequest proto.InternalMessageInfo

type QueryTotalLiquidityResponse struct {
	Liquidity github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=liquidity,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"liquidity" yaml:"liquidity"`
}

func (m *QueryTotalLiquidityResponse) Reset()         { *m = QueryTotalLiquidityResponse{} }
func (m *QueryTotalLiquidityResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTotalLiquidityResponse) ProtoMessage()    {}
func (*QueryTotalLiquidityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{13}
}
func (m *QueryTotalLiquidityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTotalLiquidityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTotalLiquidityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTotalLiquidityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTotalLiquidityResponse.Merge(m, src)
}
func (m *QueryTotalLiquidityResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTotalLiquidityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTotalLiquidityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTotalLiquidityResponse proto.InternalMessageInfo

func (m *QueryTotalLiquidityResponse) GetLiquidity() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Liquidity
	}
	return nil
}

// --------------------------------------------
// Query total liquidity for a pool
type QueryTotalPoolLiquidityRequest struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
}

func (m *QueryTotalPoolLiquidityRequest) Reset()         { *m = QueryTotalPoolLiquidityRequest{} }
func (m *QueryTotalPoolLiquidityRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTotalPoolLiquidityRequest) ProtoMessage()    {}
func (*QueryTotalPoolLiquidityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{14}
}
func (m *QueryTotalPoolLiquidityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTotalPoolLiquidityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTotalPoolLiquidityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTotalPoolLiquidityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTotalPoolLiquidityRequest.Merge(m, src)
}
func (m *QueryTotalPoolLiquidityRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTotalPoolLiquidityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTotalPoolLiquidityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTotalPoolLiquidityRequest proto.InternalMessageInfo

func (m *QueryTotalPoolLiquidityRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type QueryTotalPoolLiquidityResponse struct {
	Liquidity github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=liquidity,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"liquidity" yaml:"liquidity"`
}

func (m *QueryTotalPoolLiquidityResponse) Reset()         { *m = QueryTotalPoolLiquidityResponse{} }
func (m *QueryTotalPoolLiquidityResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTotalPoolLiquidityResponse) ProtoMessage()    {}
func (*QueryTotalPoolLiquidityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{15}
}
func (m *QueryTotalPoolLiquidityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTotalPoolLiquidityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTotalPoolLiquidityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTotalPoolLiquidityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTotalPoolLiquidityResponse.Merge(m, src)
}
func (m *QueryTotalPoolLiquidityResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTotalPoolLiquidityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTotalPoolLiquidityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTotalPoolLiquidityResponse proto.InternalMessageInfo

func (m *QueryTotalPoolLiquidityResponse) GetLiquidity() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Liquidity
	}
	return nil
}

type QueryTotalSharesRequest struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
}

func (m *QueryTotalSharesRequest) Reset()         { *m = QueryTotalSharesRequest{} }
func (m *QueryTotalSharesRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTotalSharesRequest) ProtoMessage()    {}
func (*QueryTotalSharesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{16}
}
func (m *QueryTotalSharesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTotalSharesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTotalSharesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTotalSharesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTotalSharesRequest.Merge(m, src)
}
func (m *QueryTotalSharesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTotalSharesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTotalSharesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTotalSharesRequest proto.InternalMessageInfo

func (m *QueryTotalSharesRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type QueryTotalSharesResponse struct {
	// sum of all LP tokens sent out
	TotalShares types.Coin `protobuf:"bytes,1,opt,name=total_shares,json=totalShares,proto3" json:"total_shares" yaml:"total_shares"`
}

func (m *QueryTotalSharesResponse) Reset()         { *m = QueryTotalSharesResponse{} }
func (m *QueryTotalSharesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTotalSharesResponse) ProtoMessage()    {}
func (*QueryTotalSharesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{17}
}
func (m *QueryTotalSharesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTotalSharesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTotalSharesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTotalSharesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTotalSharesResponse.Merge(m, src)
}
func (m *QueryTotalSharesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTotalSharesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTotalSharesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTotalSharesResponse proto.InternalMessageInfo

func (m *QueryTotalSharesResponse) GetTotalShares() types.Coin {
	if m != nil {
		return m.TotalShares
	}
	return types.Coin{}
}

// Returns the amount of tokenInDenom to produce 1 tokenOutDenom
// For example, if the price of NIBI = 9.123 NUSD, then setting tokenInDenom=NUSD
// and tokenOutDenom=NIBI would give "9.123".
type QuerySpotPriceRequest struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// the denomination of the token you are giving into the pool
	TokenInDenom string `protobuf:"bytes,2,opt,name=token_in_denom,json=tokenInDenom,proto3" json:"token_in_denom,omitempty"`
	// the denomination of the token you are taking out of the pool
	TokenOutDenom string `protobuf:"bytes,3,opt,name=token_out_denom,json=tokenOutDenom,proto3" json:"token_out_denom,omitempty"`
}

func (m *QuerySpotPriceRequest) Reset()         { *m = QuerySpotPriceRequest{} }
func (m *QuerySpotPriceRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySpotPriceRequest) ProtoMessage()    {}
func (*QuerySpotPriceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{18}
}
func (m *QuerySpotPriceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpotPriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpotPriceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpotPriceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpotPriceRequest.Merge(m, src)
}
func (m *QuerySpotPriceRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySpotPriceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpotPriceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpotPriceRequest proto.InternalMessageInfo

func (m *QuerySpotPriceRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *QuerySpotPriceRequest) GetTokenInDenom() string {
	if m != nil {
		return m.TokenInDenom
	}
	return ""
}

func (m *QuerySpotPriceRequest) GetTokenOutDenom() string {
	if m != nil {
		return m.TokenOutDenom
	}
	return ""
}

type QuerySpotPriceResponse struct {
	SpotPrice string `protobuf:"bytes,1,opt,name=spot_price,json=spotPrice,proto3" json:"spot_price,omitempty"`
}

func (m *QuerySpotPriceResponse) Reset()         { *m = QuerySpotPriceResponse{} }
func (m *QuerySpotPriceResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySpotPriceResponse) ProtoMessage()    {}
func (*QuerySpotPriceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{19}
}
func (m *QuerySpotPriceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpotPriceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpotPriceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpotPriceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpotPriceResponse.Merge(m, src)
}
func (m *QuerySpotPriceResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySpotPriceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpotPriceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpotPriceResponse proto.InternalMessageInfo

func (m *QuerySpotPriceResponse) GetSpotPrice() string {
	if m != nil {
		return m.SpotPrice
	}
	return ""
}

// Given an exact amount of tokens in and a target tokenOutDenom, calculates
// the expected amount of tokens out received from a swap.
type QuerySwapExactAmountInRequest struct {
	PoolId        uint64     `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	TokenIn       types.Coin `protobuf:"bytes,2,opt,name=token_in,json=tokenIn,proto3" json:"token_in" yaml:"token_in"`
	TokenOutDenom string     `protobuf:"bytes,3,opt,name=token_out_denom,json=tokenOutDenom,proto3" json:"token_out_denom,omitempty"`
}

func (m *QuerySwapExactAmountInRequest) Reset()         { *m = QuerySwapExactAmountInRequest{} }
func (m *QuerySwapExactAmountInRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySwapExactAmountInRequest) ProtoMessage()    {}
func (*QuerySwapExactAmountInRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{20}
}
func (m *QuerySwapExactAmountInRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySwapExactAmountInRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySwapExactAmountInRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySwapExactAmountInRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySwapExactAmountInRequest.Merge(m, src)
}
func (m *QuerySwapExactAmountInRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySwapExactAmountInRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySwapExactAmountInRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySwapExactAmountInRequest proto.InternalMessageInfo

func (m *QuerySwapExactAmountInRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *QuerySwapExactAmountInRequest) GetTokenIn() types.Coin {
	if m != nil {
		return m.TokenIn
	}
	return types.Coin{}
}

func (m *QuerySwapExactAmountInRequest) GetTokenOutDenom() string {
	if m != nil {
		return m.TokenOutDenom
	}
	return ""
}

type QuerySwapExactAmountInResponse struct {
	TokenOut types.Coin `protobuf:"bytes,2,opt,name=token_out,json=tokenOut,proto3" json:"token_out" yaml:"token_out"`
	Fee      types.Coin `protobuf:"bytes,3,opt,name=fee,proto3" json:"fee" yaml:"fee"`
}

func (m *QuerySwapExactAmountInResponse) Reset()         { *m = QuerySwapExactAmountInResponse{} }
func (m *QuerySwapExactAmountInResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySwapExactAmountInResponse) ProtoMessage()    {}
func (*QuerySwapExactAmountInResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{21}
}
func (m *QuerySwapExactAmountInResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySwapExactAmountInResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySwapExactAmountInResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySwapExactAmountInResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySwapExactAmountInResponse.Merge(m, src)
}
func (m *QuerySwapExactAmountInResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySwapExactAmountInResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySwapExactAmountInResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySwapExactAmountInResponse proto.InternalMessageInfo

func (m *QuerySwapExactAmountInResponse) GetTokenOut() types.Coin {
	if m != nil {
		return m.TokenOut
	}
	return types.Coin{}
}

func (m *QuerySwapExactAmountInResponse) GetFee() types.Coin {
	if m != nil {
		return m.Fee
	}
	return types.Coin{}
}

// Given an exact amount of tokens out and a target tokenInDenom, calculates
// the expected amount of tokens in required to do the swap.
type QuerySwapExactAmountOutRequest struct {
	PoolId       uint64     `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	TokenOut     types.Coin `protobuf:"bytes,2,opt,name=token_out,json=tokenOut,proto3" json:"token_out" yaml:"token_out"`
	TokenInDenom string     `protobuf:"bytes,3,opt,name=token_in_denom,json=tokenInDenom,proto3" json:"token_in_denom,omitempty"`
}

func (m *QuerySwapExactAmountOutRequest) Reset()         { *m = QuerySwapExactAmountOutRequest{} }
func (m *QuerySwapExactAmountOutRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySwapExactAmountOutRequest) ProtoMessage()    {}
func (*QuerySwapExactAmountOutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{22}
}
func (m *QuerySwapExactAmountOutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySwapExactAmountOutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySwapExactAmountOutRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySwapExactAmountOutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySwapExactAmountOutRequest.Merge(m, src)
}
func (m *QuerySwapExactAmountOutRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySwapExactAmountOutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySwapExactAmountOutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySwapExactAmountOutRequest proto.InternalMessageInfo

func (m *QuerySwapExactAmountOutRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *QuerySwapExactAmountOutRequest) GetTokenOut() types.Coin {
	if m != nil {
		return m.TokenOut
	}
	return types.Coin{}
}

func (m *QuerySwapExactAmountOutRequest) GetTokenInDenom() string {
	if m != nil {
		return m.TokenInDenom
	}
	return ""
}

type QuerySwapExactAmountOutResponse struct {
	TokenIn types.Coin `protobuf:"bytes,2,opt,name=token_in,json=tokenIn,proto3" json:"token_in" yaml:"token_in"`
}

func (m *QuerySwapExactAmountOutResponse) Reset()         { *m = QuerySwapExactAmountOutResponse{} }
func (m *QuerySwapExactAmountOutResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySwapExactAmountOutResponse) ProtoMessage()    {}
func (*QuerySwapExactAmountOutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{23}
}
func (m *QuerySwapExactAmountOutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySwapExactAmountOutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySwapExactAmountOutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySwapExactAmountOutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySwapExactAmountOutResponse.Merge(m, src)
}
func (m *QuerySwapExactAmountOutResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySwapExactAmountOutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySwapExactAmountOutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySwapExactAmountOutResponse proto.InternalMessageInfo

func (m *QuerySwapExactAmountOutResponse) GetTokenIn() types.Coin {
	if m != nil {
		return m.TokenIn
	}
	return types.Coin{}
}

type QueryJoinExactAmountInRequest struct {
	PoolId   uint64                                   `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	TokensIn github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=tokens_in,json=tokensIn,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"tokens_in" yaml:"tokens_in"`
}

func (m *QueryJoinExactAmountInRequest) Reset()         { *m = QueryJoinExactAmountInRequest{} }
func (m *QueryJoinExactAmountInRequest) String() string { return proto.CompactTextString(m) }
func (*QueryJoinExactAmountInRequest) ProtoMessage()    {}
func (*QueryJoinExactAmountInRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{24}
}
func (m *QueryJoinExactAmountInRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryJoinExactAmountInRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryJoinExactAmountInRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryJoinExactAmountInRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryJoinExactAmountInRequest.Merge(m, src)
}
func (m *QueryJoinExactAmountInRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryJoinExactAmountInRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryJoinExactAmountInRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryJoinExactAmountInRequest proto.InternalMessageInfo

func (m *QueryJoinExactAmountInRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *QueryJoinExactAmountInRequest) GetTokensIn() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TokensIn
	}
	return nil
}

type QueryJoinExactAmountInResponse struct {
	// amount of pool shares returned to user after join
	PoolSharesOut github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=pool_shares_out,json=poolSharesOut,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"pool_shares_out" yaml:"pool_shares_out"`
	// coins remaining after pool join
	RemCoins github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=rem_coins,json=remCoins,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"rem_coins" yaml:"rem_coins"`
}

func (m *QueryJoinExactAmountInResponse) Reset()         { *m = QueryJoinExactAmountInResponse{} }
func (m *QueryJoinExactAmountInResponse) String() string { return proto.CompactTextString(m) }
func (*QueryJoinExactAmountInResponse) ProtoMessage()    {}
func (*QueryJoinExactAmountInResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{25}
}
func (m *QueryJoinExactAmountInResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryJoinExactAmountInResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryJoinExactAmountInResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryJoinExactAmountInResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryJoinExactAmountInResponse.Merge(m, src)
}
func (m *QueryJoinExactAmountInResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryJoinExactAmountInResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryJoinExactAmountInResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryJoinExactAmountInResponse proto.InternalMessageInfo

func (m *QueryJoinExactAmountInResponse) GetRemCoins() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.RemCoins
	}
	return nil
}

type QueryJoinExactAmountOutRequest struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
}

func (m *QueryJoinExactAmountOutRequest) Reset()         { *m = QueryJoinExactAmountOutRequest{} }
func (m *QueryJoinExactAmountOutRequest) String() string { return proto.CompactTextString(m) }
func (*QueryJoinExactAmountOutRequest) ProtoMessage()    {}
func (*QueryJoinExactAmountOutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{26}
}
func (m *QueryJoinExactAmountOutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryJoinExactAmountOutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryJoinExactAmountOutRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryJoinExactAmountOutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryJoinExactAmountOutRequest.Merge(m, src)
}
func (m *QueryJoinExactAmountOutRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryJoinExactAmountOutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryJoinExactAmountOutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryJoinExactAmountOutRequest proto.InternalMessageInfo

func (m *QueryJoinExactAmountOutRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type QueryJoinExactAmountOutResponse struct {
}

func (m *QueryJoinExactAmountOutResponse) Reset()         { *m = QueryJoinExactAmountOutResponse{} }
func (m *QueryJoinExactAmountOutResponse) String() string { return proto.CompactTextString(m) }
func (*QueryJoinExactAmountOutResponse) ProtoMessage()    {}
func (*QueryJoinExactAmountOutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{27}
}
func (m *QueryJoinExactAmountOutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryJoinExactAmountOutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryJoinExactAmountOutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryJoinExactAmountOutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryJoinExactAmountOutResponse.Merge(m, src)
}
func (m *QueryJoinExactAmountOutResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryJoinExactAmountOutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryJoinExactAmountOutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryJoinExactAmountOutResponse proto.InternalMessageInfo

type QueryExitExactAmountInRequest struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// amount of pool shares to return to pool
	PoolSharesIn github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=pool_shares_in,json=poolSharesIn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"pool_shares_in" yaml:"pool_shares_in"`
}

func (m *QueryExitExactAmountInRequest) Reset()         { *m = QueryExitExactAmountInRequest{} }
func (m *QueryExitExactAmountInRequest) String() string { return proto.CompactTextString(m) }
func (*QueryExitExactAmountInRequest) ProtoMessage()    {}
func (*QueryExitExactAmountInRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{28}
}
func (m *QueryExitExactAmountInRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryExitExactAmountInRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryExitExactAmountInRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryExitExactAmountInRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryExitExactAmountInRequest.Merge(m, src)
}
func (m *QueryExitExactAmountInRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryExitExactAmountInRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryExitExactAmountInRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryExitExactAmountInRequest proto.InternalMessageInfo

func (m *QueryExitExactAmountInRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type QueryExitExactAmountInResponse struct {
	// coins obtained after exiting
	TokensOut github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=tokens_out,json=tokensOut,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"tokens_out" yaml:"tokens_out"`
	Fees      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=fees,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fees" yaml:"fees"`
}

func (m *QueryExitExactAmountInResponse) Reset()         { *m = QueryExitExactAmountInResponse{} }
func (m *QueryExitExactAmountInResponse) String() string { return proto.CompactTextString(m) }
func (*QueryExitExactAmountInResponse) ProtoMessage()    {}
func (*QueryExitExactAmountInResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{29}
}
func (m *QueryExitExactAmountInResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryExitExactAmountInResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryExitExactAmountInResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryExitExactAmountInResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryExitExactAmountInResponse.Merge(m, src)
}
func (m *QueryExitExactAmountInResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryExitExactAmountInResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryExitExactAmountInResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryExitExactAmountInResponse proto.InternalMessageInfo

func (m *QueryExitExactAmountInResponse) GetTokensOut() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TokensOut
	}
	return nil
}

func (m *QueryExitExactAmountInResponse) GetFees() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fees
	}
	return nil
}

type QueryExitExactAmountOutRequest struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
}

func (m *QueryExitExactAmountOutRequest) Reset()         { *m = QueryExitExactAmountOutRequest{} }
func (m *QueryExitExactAmountOutRequest) String() string { return proto.CompactTextString(m) }
func (*QueryExitExactAmountOutRequest) ProtoMessage()    {}
func (*QueryExitExactAmountOutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{30}
}
func (m *QueryExitExactAmountOutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryExitExactAmountOutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryExitExactAmountOutRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryExitExactAmountOutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryExitExactAmountOutRequest.Merge(m, src)
}
func (m *QueryExitExactAmountOutRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryExitExactAmountOutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryExitExactAmountOutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryExitExactAmountOutRequest proto.InternalMessageInfo

func (m *QueryExitExactAmountOutRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type QueryExitExactAmountOutResponse struct {
}

func (m *QueryExitExactAmountOutResponse) Reset()         { *m = QueryExitExactAmountOutResponse{} }
func (m *QueryExitExactAmountOutResponse) String() string { return proto.CompactTextString(m) }
func (*QueryExitExactAmountOutResponse) ProtoMessage()    {}
func (*QueryExitExactAmountOutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d81346ec2a640a1, []int{31}
}
func (m *QueryExitExactAmountOutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryExitExactAmountOutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryExitExactAmountOutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryExitExactAmountOutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryExitExactAmountOutResponse.Merge(m, src)
}
func (m *QueryExitExactAmountOutResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryExitExactAmountOutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryExitExactAmountOutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryExitExactAmountOutResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*QueryParamsRequest)(nil), "nibiru.spot.v1.QueryParamsRequest")
	proto.RegisterType((*QueryParamsResponse)(nil), "nibiru.spot.v1.QueryParamsResponse")
	proto.RegisterType((*QueryPoolNumberRequest)(nil), "nibiru.spot.v1.QueryPoolNumberRequest")
	proto.RegisterType((*QueryPoolNumberResponse)(nil), "nibiru.spot.v1.QueryPoolNumberResponse")
	proto.RegisterType((*QueryPoolRequest)(nil), "nibiru.spot.v1.QueryPoolRequest")
	proto.RegisterType((*QueryPoolResponse)(nil), "nibiru.spot.v1.QueryPoolResponse")
	proto.RegisterType((*QueryPoolsRequest)(nil), "nibiru.spot.v1.QueryPoolsRequest")
	proto.RegisterType((*QueryPoolsResponse)(nil), "nibiru.spot.v1.QueryPoolsResponse")
	proto.RegisterType((*QueryPoolParamsRequest)(nil), "nibiru.spot.v1.QueryPoolParamsRequest")
	proto.RegisterType((*QueryPoolParamsResponse)(nil), "nibiru.spot.v1.QueryPoolParamsResponse")
	proto.RegisterType((*QueryNumPoolsRequest)(nil), "nibiru.spot.v1.QueryNumPoolsRequest")
	proto.RegisterType((*QueryNumPoolsResponse)(nil), "nibiru.spot.v1.QueryNumPoolsResponse")
	proto.RegisterType((*QueryTotalLiquidityRequest)(nil), "nibiru.spot.v1.QueryTotalLiquidityRequest")
	proto.RegisterType((*QueryTotalLiquidityResponse)(nil), "nibiru.spot.v1.QueryTotalLiquidityResponse")
	proto.RegisterType((*QueryTotalPoolLiquidityRequest)(nil), "nibiru.spot.v1.QueryTotalPoolLiquidityRequest")
	proto.RegisterType((*QueryTotalPoolLiquidityResponse)(nil), "nibiru.spot.v1.QueryTotalPoolLiquidityResponse")
	proto.RegisterType((*QueryTotalSharesRequest)(nil), "nibiru.spot.v1.QueryTotalSharesRequest")
	proto.RegisterType((*QueryTotalSharesResponse)(nil), "nibiru.spot.v1.QueryTotalSharesResponse")
	proto.RegisterType((*QuerySpotPriceRequest)(nil), "nibiru.spot.v1.QuerySpotPriceRequest")
	proto.RegisterType((*QuerySpotPriceResponse)(nil), "nibiru.spot.v1.QuerySpotPriceResponse")
	proto.RegisterType((*QuerySwapExactAmountInRequest)(nil), "nibiru.spot.v1.QuerySwapExactAmountInRequest")
	proto.RegisterType((*QuerySwapExactAmountInResponse)(nil), "nibiru.spot.v1.QuerySwapExactAmountInResponse")
	proto.RegisterType((*QuerySwapExactAmountOutRequest)(nil), "nibiru.spot.v1.QuerySwapExactAmountOutRequest")
	proto.RegisterType((*QuerySwapExactAmountOutResponse)(nil), "nibiru.spot.v1.QuerySwapExactAmountOutResponse")
	proto.RegisterType((*QueryJoinExactAmountInRequest)(nil), "nibiru.spot.v1.QueryJoinExactAmountInRequest")
	proto.RegisterType((*QueryJoinExactAmountInResponse)(nil), "nibiru.spot.v1.QueryJoinExactAmountInResponse")
	proto.RegisterType((*QueryJoinExactAmountOutRequest)(nil), "nibiru.spot.v1.QueryJoinExactAmountOutRequest")
	proto.RegisterType((*QueryJoinExactAmountOutResponse)(nil), "nibiru.spot.v1.QueryJoinExactAmountOutResponse")
	proto.RegisterType((*QueryExitExactAmountInRequest)(nil), "nibiru.spot.v1.QueryExitExactAmountInRequest")
	proto.RegisterType((*QueryExitExactAmountInResponse)(nil), "nibiru.spot.v1.QueryExitExactAmountInResponse")
	proto.RegisterType((*QueryExitExactAmountOutRequest)(nil), "nibiru.spot.v1.QueryExitExactAmountOutRequest")
	proto.RegisterType((*QueryExitExactAmountOutResponse)(nil), "nibiru.spot.v1.QueryExitExactAmountOutResponse")
}

func init() { proto.RegisterFile("spot/v1/query.proto", fileDescriptor_2d81346ec2a640a1) }

var fileDescriptor_2d81346ec2a640a1 = []byte{
	// 1519 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcf, 0x6f, 0xd4, 0x46,
	0x14, 0x8e, 0x49, 0x08, 0xd9, 0x17, 0x08, 0x30, 0x09, 0x21, 0x38, 0xb0, 0x81, 0x01, 0x92, 0x34,
	0x11, 0x6b, 0x2d, 0xd0, 0x22, 0xda, 0x22, 0xd4, 0x40, 0x4a, 0xd3, 0x1f, 0x90, 0x2e, 0x55, 0xa5,
	0xb6, 0x87, 0x95, 0x93, 0x38, 0x8b, 0x21, 0xf6, 0x98, 0xf5, 0x18, 0x12, 0x15, 0x5a, 0xa9, 0x97,
	0xaa, 0xbd, 0x94, 0x8a, 0x6b, 0x0f, 0xbd, 0x54, 0x95, 0x7a, 0x69, 0xab, 0x4a, 0x55, 0x0f, 0xfd,
	0x03, 0x38, 0x22, 0xf5, 0x52, 0xf5, 0x90, 0x56, 0xd0, 0xbf, 0x80, 0xbf, 0xa0, 0x9a, 0x99, 0x67,
	0xef, 0x7a, 0x6d, 0xaf, 0xbd, 0x12, 0x87, 0x9e, 0xd8, 0x8c, 0xdf, 0x7b, 0xdf, 0xf7, 0xbe, 0xf9,
	0x3c, 0x7e, 0x03, 0x8c, 0xfa, 0x1e, 0xe3, 0xc6, 0x9d, 0xaa, 0x71, 0x3b, 0xb0, 0x9a, 0x5b, 0x15,
	0xaf, 0xc9, 0x38, 0x23, 0x23, 0xae, 0xbd, 0x62, 0x37, 0x83, 0x8a, 0x78, 0x56, 0xb9, 0x53, 0xd5,
	0xc7, 0x1a, 0xac, 0xc1, 0xe4, 0x23, 0x43, 0xfc, 0x52, 0x51, 0xfa, 0xe1, 0x06, 0x63, 0x8d, 0x0d,
	0xcb, 0x30, 0x3d, 0xdb, 0x30, 0x5d, 0x97, 0x71, 0x93, 0xdb, 0xcc, 0xf5, 0xf1, 0xe9, 0xdc, 0x2a,
	0xf3, 0x1d, 0xe6, 0x1b, 0x2b, 0xa6, 0x6f, 0xa9, 0xe2, 0xc6, 0x9d, 0xea, 0x8a, 0xc5, 0xcd, 0xaa,
	0xe1, 0x99, 0x0d, 0xdb, 0x95, 0xc1, 0x18, 0x3b, 0x16, 0x92, 0xf0, 0xcc, 0xa6, 0xe9, 0x84, 0x15,
	0x48, 0xb4, 0xca, 0xd8, 0x06, 0xae, 0x95, 0xdb, 0xab, 0x86, 0xf5, 0x56, 0x99, 0x8d, 0x95, 0xe8,
	0x18, 0x90, 0x77, 0x05, 0xd6, 0xb2, 0x2c, 0x54, 0xb3, 0x6e, 0x07, 0x96, 0xcf, 0xe9, 0x5b, 0x30,
	0x1a, 0x5b, 0xf5, 0x3d, 0xe6, 0xfa, 0x16, 0x39, 0x0b, 0x83, 0x0a, 0x70, 0x42, 0x3b, 0xaa, 0xcd,
	0x0e, 0x9f, 0x1e, 0xaf, 0xc4, 0xfb, 0xae, 0xa8, 0xf8, 0x85, 0x81, 0x47, 0xdb, 0x53, 0x7d, 0x35,
	0x8c, 0xa5, 0x13, 0x30, 0xae, 0x8a, 0x31, 0xb6, 0x71, 0x35, 0x70, 0x56, 0xac, 0x66, 0x08, 0x73,
	0x1a, 0x0e, 0x26, 0x9e, 0x20, 0xd4, 0x41, 0xd8, 0x25, 0xba, 0xa8, 0xdb, 0x6b, 0x12, 0x6b, 0xa0,
	0x36, 0x28, 0xfe, 0x5c, 0x5a, 0xa3, 0xf3, 0xb0, 0x2f, 0xca, 0xc1, 0x3a, 0xd9, 0xc1, 0x17, 0x60,
	0x7f, 0x5b, 0x30, 0x96, 0x9e, 0x85, 0x01, 0xf1, 0x18, 0x7b, 0x18, 0x4b, 0xf4, 0x20, 0x62, 0x65,
	0x04, 0xfd, 0xa8, 0x2d, 0x3d, 0xd4, 0x86, 0xbc, 0x0e, 0xd0, 0xda, 0x0f, 0x2c, 0x32, 0x5d, 0x51,
	0x32, 0x57, 0x84, 0xcc, 0x15, 0xe5, 0x0c, 0x14, 0xbb, 0xb2, 0x6c, 0x36, 0x2c, 0xcc, 0xad, 0xb5,
	0x65, 0xd2, 0x2f, 0xb4, 0x50, 0x7a, 0x55, 0x1d, 0xd9, 0xcd, 0xc1, 0x4e, 0x81, 0x2d, 0x24, 0xee,
	0xcf, 0xa4, 0xa7, 0x42, 0xc8, 0x95, 0x18, 0x95, 0x1d, 0x92, 0xca, 0x4c, 0x2e, 0x15, 0x05, 0x14,
	0xe3, 0x52, 0x6d, 0xdb, 0xa2, 0x98, 0x13, 0xb2, 0xa5, 0x7d, 0xbf, 0x6d, 0xef, 0x3a, 0x6c, 0xf2,
	0x0a, 0x0c, 0xcb, 0x9c, 0x98, 0x57, 0xf4, 0xb4, 0x46, 0x30, 0x11, 0xbc, 0xe8, 0x37, 0x1d, 0x87,
	0x31, 0x59, 0xf7, 0x6a, 0xe0, 0xb4, 0xcb, 0x4e, 0xcf, 0xc2, 0x81, 0x8e, 0x75, 0x44, 0x9b, 0x84,
	0x92, 0x1b, 0x38, 0xf5, 0x50, 0x34, 0xc1, 0x71, 0xc8, 0xc5, 0x20, 0x7a, 0x18, 0x74, 0x99, 0xf5,
	0x1e, 0xe3, 0xe6, 0xc6, 0xdb, 0xf6, 0xed, 0xc0, 0x5e, 0xb3, 0xf9, 0x56, 0x58, 0xf3, 0x1b, 0x0d,
	0x26, 0x53, 0x1f, 0x63, 0xe9, 0xfb, 0x50, 0xda, 0x08, 0x17, 0x71, 0x3f, 0x0e, 0xc5, 0xe4, 0x0d,
	0x85, 0xbd, 0xc4, 0x6c, 0x77, 0xe1, 0xb2, 0x70, 0xfd, 0xb3, 0xed, 0xa9, 0x7d, 0x5b, 0xa6, 0xb3,
	0xf1, 0x32, 0x8d, 0x32, 0xe9, 0x0f, 0x7f, 0x4f, 0xcd, 0x36, 0x6c, 0x7e, 0x23, 0x58, 0xa9, 0xac,
	0x32, 0xc7, 0xc0, 0x37, 0x52, 0xfd, 0x73, 0xca, 0x5f, 0xbb, 0x65, 0xf0, 0x2d, 0xcf, 0xf2, 0x65,
	0x11, 0xbf, 0xd6, 0x42, 0xa4, 0xe7, 0xa1, 0xdc, 0x62, 0x27, 0xfa, 0xe9, 0x6c, 0x20, 0x7b, 0x77,
	0xbe, 0xd5, 0x60, 0x2a, 0x33, 0xf7, 0xff, 0xd1, 0x5d, 0xf8, 0xf2, 0x4b, 0x86, 0xd7, 0x6f, 0x98,
	0x4d, 0x2b, 0xdf, 0x74, 0x01, 0x4c, 0x24, 0x73, 0xb0, 0x9d, 0x0f, 0x60, 0x37, 0x17, 0xcb, 0x75,
	0x5f, 0xae, 0xa3, 0xed, 0xba, 0x74, 0x34, 0x89, 0x1d, 0x8d, 0xaa, 0x8e, 0xda, 0x93, 0x69, 0x6d,
	0x98, 0xb7, 0x20, 0xe8, 0x27, 0xe8, 0xbd, 0xeb, 0x1e, 0xe3, 0xcb, 0x4d, 0x7b, 0xd5, 0xca, 0x23,
	0x4a, 0x4e, 0xc0, 0x08, 0x67, 0xb7, 0x2c, 0xb7, 0x6e, 0xbb, 0xf5, 0x35, 0xcb, 0x65, 0x8e, 0x7c,
	0x3b, 0x4b, 0xb5, 0xdd, 0x72, 0x75, 0xc9, 0xbd, 0x2c, 0xd6, 0xc8, 0x34, 0xec, 0x55, 0x51, 0x2c,
	0xe0, 0x18, 0xd6, 0x2f, 0xc3, 0xf6, 0xc8, 0xe5, 0x6b, 0x01, 0x97, 0x71, 0xf4, 0x1c, 0xbe, 0x9e,
	0x6d, 0xf8, 0xd8, 0xf4, 0x11, 0x00, 0xf1, 0x3e, 0xd5, 0x3d, 0xb1, 0x2a, 0x39, 0x94, 0x6a, 0x25,
	0x3f, 0x0c, 0xa3, 0x3f, 0x6a, 0x70, 0x44, 0x65, 0xde, 0x35, 0xbd, 0xc5, 0x4d, 0x73, 0x95, 0xbf,
	0xe6, 0xb0, 0xc0, 0xe5, 0x4b, 0x6e, 0x6e, 0x07, 0xef, 0xc0, 0x50, 0xd8, 0x01, 0x9e, 0x2c, 0x5d,
	0xa4, 0x3c, 0x88, 0x52, 0xee, 0x0d, 0xa5, 0x54, 0x89, 0xb4, 0xb6, 0x0b, 0xfb, 0x2d, 0xdc, 0xea,
	0x2f, 0x1a, 0x9a, 0x3e, 0x85, 0x31, 0xf6, 0xbc, 0x0c, 0xa5, 0xa8, 0x54, 0x3e, 0xb5, 0x89, 0xb8,
	0x6f, 0xa3, 0x4c, 0x5a, 0x1b, 0x0a, 0x91, 0xc9, 0x45, 0xe8, 0x5f, 0xb7, 0x2c, 0x49, 0xa8, 0x6b,
	0x2d, 0x82, 0xb5, 0x40, 0xd5, 0x5a, 0xb7, 0x2c, 0x5a, 0x13, 0x99, 0xf4, 0xe7, 0x0c, 0xd6, 0xd7,
	0x02, 0x9e, 0x2b, 0xf4, 0xf3, 0x6f, 0x27, 0x69, 0xbe, 0xfe, 0xa4, 0xf9, 0xa8, 0x87, 0x27, 0x44,
	0x1a, 0x65, 0x54, 0xfa, 0xf9, 0x7a, 0x80, 0xfe, 0x1a, 0xba, 0xf1, 0x4d, 0x66, 0xbb, 0xbd, 0xb9,
	0xf1, 0x1e, 0x8a, 0xe4, 0x2b, 0x2a, 0xbd, 0x9d, 0x55, 0x51, 0x66, 0x6f, 0x67, 0x95, 0xea, 0xdd,
	0x5f, 0x72, 0xe9, 0x83, 0x1d, 0xb8, 0xbd, 0x29, 0xc4, 0x51, 0x2a, 0x0f, 0xf6, 0x4a, 0xe6, 0xea,
	0xfc, 0x90, 0x7b, 0x29, 0xdf, 0xc6, 0x85, 0x37, 0x04, 0x97, 0xbf, 0xb6, 0xa7, 0xa6, 0x0b, 0xe0,
	0x2e, 0xb9, 0xfc, 0xd9, 0xf6, 0xd4, 0xb8, 0x62, 0xdd, 0x51, 0x8e, 0xd6, 0xf6, 0x88, 0x15, 0x75,
	0x22, 0x89, 0x5d, 0xbe, 0x07, 0xa5, 0xa6, 0xe5, 0xd4, 0xc5, 0x2c, 0xe7, 0xf7, 0x2c, 0x49, 0x94,
	0xd9, 0xa3, 0x24, 0x4d, 0xcb, 0x91, 0xbf, 0xa2, 0x6f, 0x53, 0x87, 0x22, 0x05, 0x0c, 0x4f, 0x8f,
	0xa1, 0xf1, 0xd2, 0x52, 0x95, 0x9a, 0xf4, 0xfb, 0xd0, 0x29, 0x8b, 0x9b, 0x36, 0xef, 0xcd, 0x29,
	0x0e, 0x8c, 0xb4, 0x2b, 0x87, 0xce, 0x2d, 0x2d, 0x5c, 0xe9, 0x79, 0x1f, 0x0e, 0x24, 0xf7, 0x41,
	0xd8, 0x79, 0x77, 0x6b, 0x1b, 0x96, 0x5c, 0xfa, 0x75, 0x68, 0x8d, 0x14, 0xa6, 0x68, 0x8d, 0x4f,
	0x01, 0xd0, 0x81, 0xca, 0x15, 0x39, 0x3b, 0xb5, 0x88, 0x3b, 0xb5, 0x3f, 0x66, 0x5e, 0xe1, 0x80,
	0xde, 0xbe, 0xb4, 0x2a, 0x51, 0x38, 0xc5, 0x85, 0x81, 0x75, 0xcb, 0x2a, 0x60, 0x92, 0x8b, 0x08,
	0x3d, 0x1c, 0x9d, 0x6f, 0x3d, 0xfa, 0x43, 0xe2, 0x44, 0xde, 0xe8, 0x90, 0xa4, 0x17, 0x6f, 0xa4,
	0xa5, 0x2a, 0x39, 0x4f, 0x7f, 0x37, 0x0a, 0x3b, 0x65, 0x0c, 0x71, 0x61, 0x50, 0x0d, 0x8d, 0x84,
	0x76, 0x0e, 0x97, 0xc9, 0x3b, 0x8d, 0x7e, 0xbc, 0x6b, 0x0c, 0x1a, 0x6f, 0xf2, 0xb3, 0x3f, 0xfe,
	0x7d, 0xb8, 0xe3, 0x00, 0x19, 0x35, 0x54, 0xb0, 0x21, 0xaf, 0x54, 0x6a, 0x90, 0x15, 0x1b, 0xd9,
	0xba, 0xa9, 0x90, 0xe9, 0xf4, 0x7a, 0x9d, 0x97, 0x1c, 0x7d, 0x26, 0x37, 0x0e, 0xb1, 0x8f, 0x4a,
	0x6c, 0x9d, 0x4c, 0xc4, 0xb1, 0x85, 0x4e, 0xae, 0x82, 0x5c, 0x87, 0x01, 0x91, 0x47, 0x8e, 0x66,
	0x96, 0x0c, 0x41, 0x8f, 0x75, 0x89, 0x40, 0xb8, 0x43, 0x12, 0x6e, 0x94, 0xec, 0x4f, 0xc0, 0x91,
	0x9b, 0xb0, 0x53, 0x8e, 0xcf, 0x24, 0xbb, 0x4c, 0x24, 0x2b, 0xed, 0x16, 0x82, 0x50, 0xba, 0x84,
	0x1a, 0x23, 0x24, 0x01, 0xe5, 0x93, 0x2f, 0x35, 0xa5, 0x2a, 0xee, 0x64, 0xb6, 0xaa, 0xf1, 0xdd,
	0x9c, 0xc9, 0x8d, 0x43, 0xec, 0x79, 0x89, 0x7d, 0x92, 0x1c, 0x4f, 0x62, 0x1b, 0x1f, 0xa3, 0x09,
	0xef, 0x87, 0x3b, 0x7c, 0x17, 0x86, 0xc2, 0xfb, 0x05, 0x39, 0x91, 0x8a, 0xd0, 0x71, 0x2d, 0xd1,
	0x4f, 0xe6, 0x44, 0x21, 0x8b, 0xb2, 0x64, 0x31, 0x41, 0xc6, 0x63, 0x2c, 0xa2, 0x7b, 0x0b, 0xf9,
	0x4a, 0x83, 0x91, 0xf8, 0x25, 0x84, 0xcc, 0xa5, 0x56, 0x4e, 0xbd, 0xc8, 0xe8, 0xf3, 0x85, 0x62,
	0x91, 0xcb, 0x09, 0xc9, 0xa5, 0x4c, 0x0e, 0xc7, 0xb8, 0xa8, 0xf1, 0x37, 0x1a, 0xcf, 0xc9, 0x4f,
	0x1a, 0x90, 0xe4, 0xe5, 0x81, 0x54, 0xb2, 0x91, 0xd2, 0x6e, 0x28, 0xba, 0x51, 0x38, 0x1e, 0xd9,
	0x9d, 0x97, 0xec, 0xce, 0x90, 0x6a, 0xd7, 0xfd, 0x52, 0x6c, 0xe5, 0x9f, 0x2d, 0xca, 0x0f, 0x35,
	0x18, 0x6e, 0xbb, 0x19, 0x90, 0x99, 0x6c, 0xec, 0xd8, 0x7d, 0x43, 0x9f, 0xcd, 0x0f, 0x44, 0x76,
	0x55, 0xc9, 0x6e, 0x9e, 0xbc, 0x50, 0x80, 0x9d, 0xfa, 0x66, 0x90, 0xcf, 0x35, 0x28, 0x45, 0x83,
	0x3b, 0x49, 0xf7, 0x4b, 0xe7, 0xc5, 0x42, 0x9f, 0xce, 0x0b, 0xeb, 0xcd, 0xdd, 0x22, 0xc7, 0x27,
	0xbf, 0x69, 0x70, 0x68, 0xd1, 0xe7, 0xb6, 0x63, 0x72, 0x2b, 0x31, 0x5e, 0x93, 0x53, 0xe9, 0x90,
	0x19, 0x17, 0x07, 0xbd, 0x52, 0x34, 0x1c, 0x99, 0xbe, 0x2a, 0x99, 0xbe, 0x44, 0xce, 0xc6, 0x98,
	0xb6, 0x38, 0x5a, 0x48, 0xcc, 0xf0, 0xef, 0x9a, 0x5e, 0xdd, 0x12, 0x35, 0xea, 0xa6, 0x2c, 0x52,
	0xb7, 0x5d, 0xf2, 0xbb, 0x06, 0x7a, 0x06, 0x75, 0xf1, 0x85, 0x2b, 0x44, 0xa6, 0xf5, 0xfd, 0xc9,
	0x70, 0x65, 0xf6, 0x24, 0x4c, 0x2f, 0x48, 0xf6, 0xe7, 0xc8, 0x8b, 0xbd, 0xb3, 0x67, 0x01, 0x8f,
	0x29, 0x9f, 0x98, 0x21, 0x33, 0x94, 0xcf, 0x1a, 0x92, 0x33, 0x94, 0xcf, 0x1c, 0x4d, 0x8b, 0x2b,
	0x7f, 0x93, 0xd9, 0x6e, 0x57, 0xe5, 0x93, 0x13, 0x1b, 0x29, 0x44, 0x26, 0x57, 0xf9, 0x2e, 0xa3,
	0x60, 0x61, 0xe5, 0x93, 0xec, 0x3b, 0x95, 0x4f, 0x8c, 0x68, 0x19, 0xca, 0x67, 0x0d, 0x9d, 0x19,
	0xca, 0x67, 0x4e, 0x7e, 0xc5, 0x95, 0xb7, 0x36, 0x6d, 0xde, 0x55, 0xf9, 0xe4, 0x3c, 0x44, 0x0a,
	0x91, 0xc9, 0x55, 0x3e, 0x7b, 0xd0, 0x2a, 0xae, 0x7c, 0x92, 0x3d, 0x0b, 0xf8, 0xc2, 0xe5, 0x47,
	0x4f, 0xca, 0xda, 0xe3, 0x27, 0x65, 0xed, 0x9f, 0x27, 0x65, 0xed, 0xc1, 0xd3, 0x72, 0xdf, 0xe3,
	0xa7, 0xe5, 0xbe, 0x3f, 0x9f, 0x96, 0xfb, 0x3e, 0x9c, 0x6b, 0x9b, 0x27, 0xaf, 0xca, 0xd2, 0x97,
	0x6e, 0x98, 0xb6, 0x1b, 0xc2, 0x6c, 0xe2, 0x07, 0x49, 0xcc, 0x95, 0x2b, 0x83, 0xf2, 0xbf, 0xa9,
	0xcf, 0xfc, 0x17, 0x00, 0x00, 0xff, 0xff, 0x33, 0x18, 0x77, 0x19, 0x77, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// Parameters of the spot module.
	Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
	// Next available pool id number.
	PoolNumber(ctx context.Context, in *QueryPoolNumberRequest, opts ...grpc.CallOption) (*QueryPoolNumberResponse, error)
	// Fetch a pool by id.
	Pool(ctx context.Context, in *QueryPoolRequest, opts ...grpc.CallOption) (*QueryPoolResponse, error)
	// Returns all pools.
	Pools(ctx context.Context, in *QueryPoolsRequest, opts ...grpc.CallOption) (*QueryPoolsResponse, error)
	// Parameters of a single pool.
	PoolParams(ctx context.Context, in *QueryPoolParamsRequest, opts ...grpc.CallOption) (*QueryPoolParamsResponse, error)
	// Number of pools.
	NumPools(ctx context.Context, in *QueryNumPoolsRequest, opts ...grpc.CallOption) (*QueryNumPoolsResponse, error)
	// Total liquidity across all pools.
	TotalLiquidity(ctx context.Context, in *QueryTotalLiquidityRequest, opts ...grpc.CallOption) (*QueryTotalLiquidityResponse, error)
	// Total liquidity in a single pool.
	TotalPoolLiquidity(ctx context.Context, in *QueryTotalPoolLiquidityRequest, opts ...grpc.CallOption) (*QueryTotalPoolLiquidityResponse, error)
	// Total shares in a single pool.
	TotalShares(ctx context.Context, in *QueryTotalSharesRequest, opts ...grpc.CallOption) (*QueryTotalSharesResponse, error)
	// Instantaneous price of an asset in a pool.
	SpotPrice(ctx context.Context, in *QuerySpotPriceRequest, opts ...grpc.CallOption) (*QuerySpotPriceResponse, error)
	// Estimates the amount of assets returned given an exact amount of tokens to
	// swap.
	EstimateSwapExactAmountIn(ctx context.Context, in *QuerySwapExactAmountInRequest, opts ...grpc.CallOption) (*QuerySwapExactAmountInResponse, error)
	// Estimates the amount of tokens required to return the exact amount of
	// assets requested.
	EstimateSwapExactAmountOut(ctx context.Context, in *QuerySwapExactAmountOutRequest, opts ...grpc.CallOption) (*QuerySwapExactAmountOutResponse, error)
	// Estimates the amount of pool shares returned given an amount of tokens to
	// join.
	EstimateJoinExactAmountIn(ctx context.Context, in *QueryJoinExactAmountInRequest, opts ...grpc.CallOption) (*QueryJoinExactAmountInResponse, error)
	// Estimates the amount of tokens required to obtain an exact amount of pool
	// shares.
	EstimateJoinExactAmountOut(ctx context.Context, in *QueryJoinExactAmountOutRequest, opts ...grpc.CallOption) (*QueryJoinExactAmountOutResponse, error)
	// Estimates the amount of tokens returned to the user given an exact amount
	// of pool shares.
	EstimateExitExactAmountIn(ctx context.Context, in *QueryExitExactAmountInRequest, opts ...grpc.CallOption) (*QueryExitExactAmountInResponse, error)
	// Estimates the amount of pool shares required to extract an exact amount of
	// tokens from the pool.
	EstimateExitExactAmountOut(ctx context.Context, in *QueryExitExactAmountOutRequest, opts ...grpc.CallOption) (*QueryExitExactAmountOutResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) {
	out := new(QueryParamsResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/Params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) PoolNumber(ctx context.Context, in *QueryPoolNumberRequest, opts ...grpc.CallOption) (*QueryPoolNumberResponse, error) {
	out := new(QueryPoolNumberResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/PoolNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Pool(ctx context.Context, in *QueryPoolRequest, opts ...grpc.CallOption) (*QueryPoolResponse, error) {
	out := new(QueryPoolResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/Pool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Pools(ctx context.Context, in *QueryPoolsRequest, opts ...grpc.CallOption) (*QueryPoolsResponse, error) {
	out := new(QueryPoolsResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/Pools", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) PoolParams(ctx context.Context, in *QueryPoolParamsRequest, opts ...grpc.CallOption) (*QueryPoolParamsResponse, error) {
	out := new(QueryPoolParamsResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/PoolParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) NumPools(ctx context.Context, in *QueryNumPoolsRequest, opts ...grpc.CallOption) (*QueryNumPoolsResponse, error) {
	out := new(QueryNumPoolsResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/NumPools", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TotalLiquidity(ctx context.Context, in *QueryTotalLiquidityRequest, opts ...grpc.CallOption) (*QueryTotalLiquidityResponse, error) {
	out := new(QueryTotalLiquidityResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/TotalLiquidity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TotalPoolLiquidity(ctx context.Context, in *QueryTotalPoolLiquidityRequest, opts ...grpc.CallOption) (*QueryTotalPoolLiquidityResponse, error) {
	out := new(QueryTotalPoolLiquidityResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/TotalPoolLiquidity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TotalShares(ctx context.Context, in *QueryTotalSharesRequest, opts ...grpc.CallOption) (*QueryTotalSharesResponse, error) {
	out := new(QueryTotalSharesResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/TotalShares", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) SpotPrice(ctx context.Context, in *QuerySpotPriceRequest, opts ...grpc.CallOption) (*QuerySpotPriceResponse, error) {
	out := new(QuerySpotPriceResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/SpotPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) EstimateSwapExactAmountIn(ctx context.Context, in *QuerySwapExactAmountInRequest, opts ...grpc.CallOption) (*QuerySwapExactAmountInResponse, error) {
	out := new(QuerySwapExactAmountInResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/EstimateSwapExactAmountIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) EstimateSwapExactAmountOut(ctx context.Context, in *QuerySwapExactAmountOutRequest, opts ...grpc.CallOption) (*QuerySwapExactAmountOutResponse, error) {
	out := new(QuerySwapExactAmountOutResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/EstimateSwapExactAmountOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) EstimateJoinExactAmountIn(ctx context.Context, in *QueryJoinExactAmountInRequest, opts ...grpc.CallOption) (*QueryJoinExactAmountInResponse, error) {
	out := new(QueryJoinExactAmountInResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/EstimateJoinExactAmountIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) EstimateJoinExactAmountOut(ctx context.Context, in *QueryJoinExactAmountOutRequest, opts ...grpc.CallOption) (*QueryJoinExactAmountOutResponse, error) {
	out := new(QueryJoinExactAmountOutResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/EstimateJoinExactAmountOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) EstimateExitExactAmountIn(ctx context.Context, in *QueryExitExactAmountInRequest, opts ...grpc.CallOption) (*QueryExitExactAmountInResponse, error) {
	out := new(QueryExitExactAmountInResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/EstimateExitExactAmountIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) EstimateExitExactAmountOut(ctx context.Context, in *QueryExitExactAmountOutRequest, opts ...grpc.CallOption) (*QueryExitExactAmountOutResponse, error) {
	out := new(QueryExitExactAmountOutResponse)
	err := c.cc.Invoke(ctx, "/nibiru.spot.v1.Query/EstimateExitExactAmountOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// Parameters of the spot module.
	Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
	// Next available pool id number.
	PoolNumber(context.Context, *QueryPoolNumberRequest) (*QueryPoolNumberResponse, error)
	// Fetch a pool by id.
	Pool(context.Context, *QueryPoolRequest) (*QueryPoolResponse, error)
	// Returns all pools.
	Pools(context.Context, *QueryPoolsRequest) (*QueryPoolsResponse, error)
	// Parameters of a single pool.
	PoolParams(context.Context, *QueryPoolParamsRequest) (*QueryPoolParamsResponse, error)
	// Number of pools.
	NumPools(context.Context, *QueryNumPoolsRequest) (*QueryNumPoolsResponse, error)
	// Total liquidity across all pools.
	TotalLiquidity(context.Context, *QueryTotalLiquidityRequest) (*QueryTotalLiquidityResponse, error)
	// Total liquidity in a single pool.
	TotalPoolLiquidity(context.Context, *QueryTotalPoolLiquidityRequest) (*QueryTotalPoolLiquidityResponse, error)
	// Total shares in a single pool.
	TotalShares(context.Context, *QueryTotalSharesRequest) (*QueryTotalSharesResponse, error)
	// Instantaneous price of an asset in a pool.
	SpotPrice(context.Context, *QuerySpotPriceRequest) (*QuerySpotPriceResponse, error)
	// Estimates the amount of assets returned given an exact amount of tokens to
	// swap.
	EstimateSwapExactAmountIn(context.Context, *QuerySwapExactAmountInRequest) (*QuerySwapExactAmountInResponse, error)
	// Estimates the amount of tokens required to return the exact amount of
	// assets requested.
	EstimateSwapExactAmountOut(context.Context, *QuerySwapExactAmountOutRequest) (*QuerySwapExactAmountOutResponse, error)
	// Estimates the amount of pool shares returned given an amount of tokens to
	// join.
	EstimateJoinExactAmountIn(context.Context, *QueryJoinExactAmountInRequest) (*QueryJoinExactAmountInResponse, error)
	// Estimates the amount of tokens required to obtain an exact amount of pool
	// shares.
	EstimateJoinExactAmountOut(context.Context, *QueryJoinExactAmountOutRequest) (*QueryJoinExactAmountOutResponse, error)
	// Estimates the amount of tokens returned to the user given an exact amount
	// of pool shares.
	EstimateExitExactAmountIn(context.Context, *QueryExitExactAmountInRequest) (*QueryExitExactAmountInResponse, error)
	// Estimates the amount of pool shares required to extract an exact amount of
	// tokens from the pool.
	EstimateExitExactAmountOut(context.Context, *QueryExitExactAmountOutRequest) (*QueryExitExactAmountOutResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (*UnimplementedQueryServer) PoolNumber(ctx context.Context, req *QueryPoolNumberRequest) (*QueryPoolNumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PoolNumber not implemented")
}
func (*UnimplementedQueryServer) Pool(ctx context.Context, req *QueryPoolRequest) (*QueryPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pool not implemented")
}
func (*UnimplementedQueryServer) Pools(ctx context.Context, req *QueryPoolsRequest) (*QueryPoolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pools not implemented")
}
func (*UnimplementedQueryServer) PoolParams(ctx context.Context, req *QueryPoolParamsRequest) (*QueryPoolParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PoolParams not implemented")
}
func (*UnimplementedQueryServer) NumPools(ctx context.Context, req *QueryNumPoolsRequest) (*QueryNumPoolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NumPools not implemented")
}
func (*UnimplementedQueryServer) TotalLiquidity(ctx context.Context, req *QueryTotalLiquidityRequest) (*QueryTotalLiquidityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TotalLiquidity not implemented")
}
func (*UnimplementedQueryServer) TotalPoolLiquidity(ctx context.Context, req *QueryTotalPoolLiquidityRequest) (*QueryTotalPoolLiquidityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TotalPoolLiquidity not implemented")
}
func (*UnimplementedQueryServer) TotalShares(ctx context.Context, req *QueryTotalSharesRequest) (*QueryTotalSharesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TotalShares not implemented")
}
func (*UnimplementedQueryServer) SpotPrice(ctx context.Context, req *QuerySpotPriceRequest) (*QuerySpotPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpotPrice not implemented")
}
func (*UnimplementedQueryServer) EstimateSwapExactAmountIn(ctx context.Context, req *QuerySwapExactAmountInRequest) (*QuerySwapExactAmountInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateSwapExactAmountIn not implemented")
}
func (*UnimplementedQueryServer) EstimateSwapExactAmountOut(ctx context.Context, req *QuerySwapExactAmountOutRequest) (*QuerySwapExactAmountOutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateSwapExactAmountOut not implemented")
}
func (*UnimplementedQueryServer) EstimateJoinExactAmountIn(ctx context.Context, req *QueryJoinExactAmountInRequest) (*QueryJoinExactAmountInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateJoinExactAmountIn not implemented")
}
func (*UnimplementedQueryServer) EstimateJoinExactAmountOut(ctx context.Context, req *QueryJoinExactAmountOutRequest) (*QueryJoinExactAmountOutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateJoinExactAmountOut not implemented")
}
func (*UnimplementedQueryServer) EstimateExitExactAmountIn(ctx context.Context, req *QueryExitExactAmountInRequest) (*QueryExitExactAmountInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateExitExactAmountIn not implemented")
}
func (*UnimplementedQueryServer) EstimateExitExactAmountOut(ctx context.Context, req *QueryExitExactAmountOutRequest) (*QueryExitExactAmountOutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateExitExactAmountOut not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/Params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_PoolNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPoolNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).PoolNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/PoolNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).PoolNumber(ctx, req.(*QueryPoolNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Pool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Pool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/Pool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Pool(ctx, req.(*QueryPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Pools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPoolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Pools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/Pools",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Pools(ctx, req.(*QueryPoolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_PoolParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPoolParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).PoolParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/PoolParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).PoolParams(ctx, req.(*QueryPoolParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_NumPools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNumPoolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).NumPools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/NumPools",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).NumPools(ctx, req.(*QueryNumPoolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TotalLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTotalLiquidityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TotalLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/TotalLiquidity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TotalLiquidity(ctx, req.(*QueryTotalLiquidityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TotalPoolLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTotalPoolLiquidityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TotalPoolLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/TotalPoolLiquidity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TotalPoolLiquidity(ctx, req.(*QueryTotalPoolLiquidityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TotalShares_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTotalSharesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TotalShares(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/TotalShares",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TotalShares(ctx, req.(*QueryTotalSharesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_SpotPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySpotPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).SpotPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/SpotPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).SpotPrice(ctx, req.(*QuerySpotPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_EstimateSwapExactAmountIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySwapExactAmountInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).EstimateSwapExactAmountIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/EstimateSwapExactAmountIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).EstimateSwapExactAmountIn(ctx, req.(*QuerySwapExactAmountInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_EstimateSwapExactAmountOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySwapExactAmountOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).EstimateSwapExactAmountOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/EstimateSwapExactAmountOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).EstimateSwapExactAmountOut(ctx, req.(*QuerySwapExactAmountOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_EstimateJoinExactAmountIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryJoinExactAmountInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).EstimateJoinExactAmountIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/EstimateJoinExactAmountIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).EstimateJoinExactAmountIn(ctx, req.(*QueryJoinExactAmountInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_EstimateJoinExactAmountOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryJoinExactAmountOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).EstimateJoinExactAmountOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/EstimateJoinExactAmountOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).EstimateJoinExactAmountOut(ctx, req.(*QueryJoinExactAmountOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_EstimateExitExactAmountIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryExitExactAmountInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).EstimateExitExactAmountIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/EstimateExitExactAmountIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).EstimateExitExactAmountIn(ctx, req.(*QueryExitExactAmountInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_EstimateExitExactAmountOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryExitExactAmountOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).EstimateExitExactAmountOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nibiru.spot.v1.Query/EstimateExitExactAmountOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).EstimateExitExactAmountOut(ctx, req.(*QueryExitExactAmountOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nibiru.spot.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Params",
			Handler:    _Query_Params_Handler,
		},
		{
			MethodName: "PoolNumber",
			Handler:    _Query_PoolNumber_Handler,
		},
		{
			MethodName: "Pool",
			Handler:    _Query_Pool_Handler,
		},
		{
			MethodName: "Pools",
			Handler:    _Query_Pools_Handler,
		},
		{
			MethodName: "PoolParams",
			Handler:    _Query_PoolParams_Handler,
		},
		{
			MethodName: "NumPools",
			Handler:    _Query_NumPools_Handler,
		},
		{
			MethodName: "TotalLiquidity",
			Handler:    _Query_TotalLiquidity_Handler,
		},
		{
			MethodName: "TotalPoolLiquidity",
			Handler:    _Query_TotalPoolLiquidity_Handler,
		},
		{
			MethodName: "TotalShares",
			Handler:    _Query_TotalShares_Handler,
		},
		{
			MethodName: "SpotPrice",
			Handler:    _Query_SpotPrice_Handler,
		},
		{
			MethodName: "EstimateSwapExactAmountIn",
			Handler:    _Query_EstimateSwapExactAmountIn_Handler,
		},
		{
			MethodName: "EstimateSwapExactAmountOut",
			Handler:    _Query_EstimateSwapExactAmountOut_Handler,
		},
		{
			MethodName: "EstimateJoinExactAmountIn",
			Handler:    _Query_EstimateJoinExactAmountIn_Handler,
		},
		{
			MethodName: "EstimateJoinExactAmountOut",
			Handler:    _Query_EstimateJoinExactAmountOut_Handler,
		},
		{
			MethodName: "EstimateExitExactAmountIn",
			Handler:    _Query_EstimateExitExactAmountIn_Handler,
		},
		{
			MethodName: "EstimateExitExactAmountOut",
			Handler:    _Query_EstimateExitExactAmountOut_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "spot/v1/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryPoolNumberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoolNumberRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoolNumberRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryPoolNumberResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoolNumberResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoolNumberResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryPoolRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoolRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoolRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pool != nil {
		{
			size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryPoolsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoolsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoolsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryPoolsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoolsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoolsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryPoolParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoolParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoolParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryPoolParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoolParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoolParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolParams != nil {
		{
			size, err := m.PoolParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryNumPoolsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryNumPoolsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryNumPoolsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryNumPoolsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryNumPoolsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryNumPoolsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumPools != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.NumPools))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryTotalLiquidityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTotalLiquidityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTotalLiquidityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryTotalLiquidityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTotalLiquidityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTotalLiquidityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Liquidity) > 0 {
		for iNdEx := len(m.Liquidity) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Liquidity[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryTotalPoolLiquidityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTotalPoolLiquidityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTotalPoolLiquidityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryTotalPoolLiquidityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTotalPoolLiquidityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTotalPoolLiquidityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Liquidity) > 0 {
		for iNdEx := len(m.Liquidity) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Liquidity[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryTotalSharesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTotalSharesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTotalSharesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryTotalSharesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTotalSharesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTotalSharesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TotalShares.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QuerySpotPriceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpotPriceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpotPriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenOutDenom) > 0 {
		i -= len(m.TokenOutDenom)
		copy(dAtA[i:], m.TokenOutDenom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TokenOutDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TokenInDenom) > 0 {
		i -= len(m.TokenInDenom)
		copy(dAtA[i:], m.TokenInDenom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TokenInDenom)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QuerySpotPriceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpotPriceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpotPriceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpotPrice) > 0 {
		i -= len(m.SpotPrice)
		copy(dAtA[i:], m.SpotPrice)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SpotPrice)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySwapExactAmountInRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySwapExactAmountInRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySwapExactAmountInRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenOutDenom) > 0 {
		i -= len(m.TokenOutDenom)
		copy(dAtA[i:], m.TokenOutDenom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TokenOutDenom)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.TokenIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QuerySwapExactAmountInResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySwapExactAmountInResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySwapExactAmountInResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.TokenOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *QuerySwapExactAmountOutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySwapExactAmountOutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySwapExactAmountOutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenInDenom) > 0 {
		i -= len(m.TokenInDenom)
		copy(dAtA[i:], m.TokenInDenom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TokenInDenom)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.TokenOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QuerySwapExactAmountOutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySwapExactAmountOutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySwapExactAmountOutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TokenIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *QueryJoinExactAmountInRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryJoinExactAmountInRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryJoinExactAmountInRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokensIn) > 0 {
		for iNdEx := len(m.TokensIn) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokensIn[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryJoinExactAmountInResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryJoinExactAmountInResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryJoinExactAmountInResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemCoins) > 0 {
		for iNdEx := len(m.RemCoins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemCoins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.PoolSharesOut.Size()
		i -= size
		if _, err := m.PoolSharesOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryJoinExactAmountOutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryJoinExactAmountOutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryJoinExactAmountOutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryJoinExactAmountOutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryJoinExactAmountOutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryJoinExactAmountOutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryExitExactAmountInRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryExitExactAmountInRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryExitExactAmountInRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PoolSharesIn.Size()
		i -= size
		if _, err := m.PoolSharesIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryExitExactAmountInResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryExitExactAmountInResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryExitExactAmountInResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fees) > 0 {
		for iNdEx := len(m.Fees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TokensOut) > 0 {
		for iNdEx := len(m.TokensOut) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokensOut[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryExitExactAmountOutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryExitExactAmountOutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryExitExactAmountOutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryExitExactAmountOutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryExitExactAmountOutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryExitExactAmountOutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryPoolNumberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryPoolNumberResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	return n
}

func (m *QueryPoolRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	return n
}

func (m *QueryPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pool != nil {
		l = m.Pool.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryPoolsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryPoolsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryPoolParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	return n
}

func (m *QueryPoolParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolParams != nil {
		l = m.PoolParams.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryNumPoolsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryNumPoolsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumPools != 0 {
		n += 1 + sovQuery(uint64(m.NumPools))
	}
	return n
}

func (m *QueryTotalLiquidityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryTotalLiquidityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Liquidity) > 0 {
		for _, e := range m.Liquidity {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryTotalPoolLiquidityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	return n
}

func (m *QueryTotalPoolLiquidityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Liquidity) > 0 {
		for _, e := range m.Liquidity {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryTotalSharesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	return n
}

func (m *QueryTotalSharesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalShares.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QuerySpotPriceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	l = len(m.TokenInDenom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TokenOutDenom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySpotPriceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpotPrice)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySwapExactAmountInRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	l = m.TokenIn.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.TokenOutDenom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySwapExactAmountInResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TokenOut.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QuerySwapExactAmountOutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	l = m.TokenOut.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.TokenInDenom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySwapExactAmountOutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TokenIn.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryJoinExactAmountInRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	if len(m.TokensIn) > 0 {
		for _, e := range m.TokensIn {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryJoinExactAmountInResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PoolSharesOut.Size()
	n += 1 + l + sovQuery(uint64(l))
	if len(m.RemCoins) > 0 {
		for _, e := range m.RemCoins {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryJoinExactAmountOutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	return n
}

func (m *QueryJoinExactAmountOutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryExitExactAmountInRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	l = m.PoolSharesIn.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryExitExactAmountInResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TokensOut) > 0 {
		for _, e := range m.TokensOut {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Fees) > 0 {
		for _, e := range m.Fees {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryExitExactAmountOutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovQuery(uint64(m.PoolId))
	}
	return n
}

func (m *QueryExitExactAmountOutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoolNumberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoolNumberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoolNumberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoolNumberResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoolNumberResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoolNumberResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoolRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoolRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoolRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pool == nil {
				m.Pool = &Pool{}
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoolsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoolsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoolsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoolsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoolsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoolsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &Pool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoolParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoolParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoolParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoolParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoolParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoolParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoolParams == nil {
				m.PoolParams = &PoolParams{}
			}
			if err := m.PoolParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryNumPoolsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryNumPoolsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryNumPoolsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryNumPoolsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryNumPoolsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryNumPoolsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPools", wireType)
			}
			m.NumPools = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPools |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTotalLiquidityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTotalLiquidityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTotalLiquidityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTotalLiquidityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTotalLiquidityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTotalLiquidityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Liquidity = append(m.Liquidity, types.Coin{})
			if err := m.Liquidity[len(m.Liquidity)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTotalPoolLiquidityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTotalPoolLiquidityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTotalPoolLiquidityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTotalPoolLiquidityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTotalPoolLiquidityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTotalPoolLiquidityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Liquidity = append(m.Liquidity, types.Coin{})
			if err := m.Liquidity[len(m.Liquidity)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTotalSharesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTotalSharesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTotalSharesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTotalSharesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTotalSharesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTotalSharesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShares", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpotPriceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySpotPriceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySpotPriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenInDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenInDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOutDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenOutDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpotPriceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySpotPriceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySpotPriceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySwapExactAmountInRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySwapExactAmountInRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySwapExactAmountInRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOutDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenOutDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySwapExactAmountInResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySwapExactAmountInResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySwapExactAmountInResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySwapExactAmountOutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySwapExactAmountOutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySwapExactAmountOutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenInDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenInDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySwapExactAmountOutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySwapExactAmountOutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySwapExactAmountOutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryJoinExactAmountInRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryJoinExactAmountInRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryJoinExactAmountInRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokensIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokensIn = append(m.TokensIn, types.Coin{})
			if err := m.TokensIn[len(m.TokensIn)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryJoinExactAmountInResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryJoinExactAmountInResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryJoinExactAmountInResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolSharesOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolSharesOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemCoins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemCoins = append(m.RemCoins, types.Coin{})
			if err := m.RemCoins[len(m.RemCoins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryJoinExactAmountOutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryJoinExactAmountOutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryJoinExactAmountOutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryJoinExactAmountOutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryJoinExactAmountOutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryJoinExactAmountOutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryExitExactAmountInRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryExitExactAmountInRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryExitExactAmountInRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolSharesIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolSharesIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryExitExactAmountInResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryExitExactAmountInResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryExitExactAmountInResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokensOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokensOut = append(m.TokensOut, types.Coin{})
			if err := m.TokensOut[len(m.TokensOut)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fees = append(m.Fees, types.Coin{})
			if err := m.Fees[len(m.Fees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryExitExactAmountOutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryExitExactAmountOutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryExitExactAmountOutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryExitExactAmountOutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryExitExactAmountOutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryExitExactAmountOutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
